---
description: 列表分页功能的接口和前端规范
globs: 
alwaysApply: false
---
# 分页规范更新

## 后端规范更新 (backend-structure)

在 **API设计规范** 部分增加以下内容：

### 7. 分页规范

#### 统一分页参数

所有分页接口必须支持以下查询参数：

```python
page: int = Query(1, ge=1, description="页码，从1开始")
page_size: int = Query(20, ge=1, le=100, description="每页条数，默认20，最大100")
sort_by: str = Query("created_at", description="排序字段")
sort_order: str = Query("desc", regex="^(asc|desc)$", description="排序方向")
search: str = Query("", description="搜索关键词")
```

#### 统一分页响应格式

所有分页接口必须返回 `PaginatedResponse` 格式：

```json
{
  "data": [/* 数据列表 */],
  "meta": {
    "page": 1,           // 当前页码
    "page_size": 20,     // 每页条数
    "total": 100,        // 总条数
    "total_pages": 5,    // 总页数
    "has_next": true,    // 是否有下一页
    "has_prev": false    // 是否有上一页
  }
}
```

#### Schema定义

使用统一的分页Schema：

```python
from app.schemas.pagination import PaginatedResponse, PaginationParams, SortParams

# API端点示例
@router.get("/items", response_model=PaginatedResponse[YourModel])
async def list_items(
    page: int = Query(1, ge=1),
    page_size: int = Query(20, ge=1, le=100),
    sort_by: str = Query("created_at"),
    sort_order: str = Query("desc"),
    search: str = Query(""),
    service: YourService = Depends(),
) -> Any:
    return await service.get_items_paginated(...)
```

#### 服务层实现模式

```python
async def get_items_paginated(
    self,
    page: int = 1,
    page_size: int = 20,
    sort_by: str = "created_at",
    sort_order: str = "desc",
    search: str = "",
) -> PaginatedResponse[YourModel]:
    # 构建查询
    base_query = select(YourModel)
    
    # 添加搜索
    if search:
        base_query = base_query.where(...)
    
    # 获取总数
    count_query = select(func.count()).select_from(base_query.subquery())
    total = (await self.db.execute(count_query)).scalar()
    
    # 排序和分页
    query = base_query.order_by(...).offset(...).limit(...)
    items = (await self.db.execute(query)).scalars().all()
    
    return PaginatedResponse.create(
        data=list(items), total=total, page=page, page_size=page_size
    )
```

---

## 前端规范更新 (frontend-structure)

在 **API集成规范** 部分增加以下内容：

### 5. 分页API集成规范

#### 类型定义

创建 `src/types/Pagination.ts`：

```typescript
// 分页参数
interface PaginationParams {
  page?: number;
  page_size?: number;
}

// 分页响应
interface PaginatedResponse<T> {
  data: T[];
  meta: {
    page: number;
    page_size: number;
    total: number;
    total_pages: number;
    has_next: boolean;
    has_prev: boolean;
  };
}
```

#### API调用标准

```typescript
export const YourAPI = {
  getItems: (params?: {
    page?: number;
    page_size?: number;
    sort_by?: string;
    sort_order?: 'asc' | 'desc';
    search?: string;
  }) => {
    const searchParams = new URLSearchParams();
    // 添加参数
    const url = `/api/items${searchParams.toString() ? `?${searchParams}` : ''}`;
    return http.get(url);
  },
};
```

#### ProTable集成标准

```typescript
<EditableProTable<YourType>
  request={async (params, sort) => {
    // 处理排序
    const sortField = Object.keys(sort || {})[0] || 'created_at';
    const sortOrder = Object.values(sort || {})[0] === 'ascend' ? 'asc' : 'desc';
    
    // 计算分页参数
    const current = params.current || 1;
    const pageSize = params.pageSize || 20;
    const page = Math.ceil(((current - 1) * pageSize) / 20) + 1;
    
    const response = await YourAPI.getItems({
      search: params.search || '',
      sort_by: sortField,
      sort_order: sortOrder,
      page: page,
      page_size: 20,
    });

    const { data: items, meta } = response.data;
    
    return {
      data: items,
      success: true,
      total: meta.total,
    };
  }}
  pagination={{
    pageSize: 20,
    showSizeChanger: true,
    showQuickJumper: true,
    showTotal: (total, range) => 
      `第 ${range[0]}-${range[1]} 条/总共 ${total} 条`,
  }}
/>
```

### 性能优化规范

在 **性能优化规范** 部分增加：

#### 4. 分页性能优化

- **默认分页大小**：20条，平衡性能和用户体验
- **最大分页限制**：100条/页，防止单次查询过多数据
- **索引优化**：为常用排序字段添加数据库索引
- **缓存策略**：考虑对查询结果进行适当缓存
- **预加载**：在用户浏览时预加载下一页数据
- **虚拟滚动**：对于超大数据集，考虑使用虚拟滚动

#### 分页最佳实践

1. **用户体验**
   - 显示总条数和当前范围
   - 提供页码跳转功能
   - 支持每页大小切换
   - 保持分页状态不丢失

2. **错误处理**
   - 页码超出范围时自动调整
   - 网络错误友好提示
   - 提供重试机制

3. **状态管理**
   - 分页状态在路由参数中维护
   - 支持浏览器前进后退
   - 表格刷新保持当前页 